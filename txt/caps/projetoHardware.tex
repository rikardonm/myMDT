\chapter{Projeto de Hardware}\label{cap:hw}

	O desenvolvimento da plataforma proposta na Figura \ref{img:sys:blocks} pode ser dividida em dois grupos: \textit{hardware} e \textit{software}. O desenvolvimento do \textit{hardware} pode ser divido novamente, de acordo com a Figura \ref{img:sys:mine}, em: módulos de medição e sistema de controle. A seção \ref{sec:hw:sch} detalha o desenvolvimento do módulo, enquanto que a seção \ref{sec:hw:firmware} apresenta o \textit{hardware} utilizado para o circuito de controle, bem como os principais blocos do \textit{firmware} desenvolvido.


	\section{Módulo de Medição}\label{sec:hw:sch}

		O módulo de medição é constituído por três elementos principais: condicionamento analógico do sinal, conversão A/D e isolação entre usuário e grandeza. O condicionamento do sinal tem a finalidade de ajustar o nível do sinal recebido do sensor à faixa de operação do ADC. Em casos em que o sinal do sensor excede a faixa de operação do ADC, o estágio de condicionamento deve atuar como atenuador. Em casos em que o sinal do sensor é menor, o estágio condicionador poderá atuar como um estágio de amplificação.

		A amplificação do sinal, anterior ao ADC, visa a redução do erro de quantização inerente ao processo de conversão. Este erro é mais significativo em sinais de menor amplitude.

			\subsection{Condicionamento Analógico do Sinal}\label{sec:hw:sch:analog}
			%does that mean that i've given up this life?

				A base de funcionamento do bloco de condicionamento é o amplificador analógico. Muitos instrumentos utilizam uma seleção de faixas de operação manual, em que os resistores de ganho na malha de amplificação são alterados. Esta solução é de baixo custo, porém envolve partes móveis conectadas ao referencial da grandeza. A redução de partes móveis de um sistema aumenta sua confiabilidade, durabilidade e robustez devido à redução do número de falhas.

				Uma alternativa a esta topologia é o uso de amplificadores programáveis. Estes dispositivos possuem uma rede de resistores integradas ao \textit{die} de silício, controlada por uma interface digital. Neste trabalho, o amplificador PGA281 da Texas Instruments\textsuperscript{\textregistered} foi utilizado. Conforme o \textit{datasheet} \cite{pga281}, suas principais características são:

				\begin{itemize}
					\item Ganho variável em passos binários de \nicefrac{1}{8} a 128;
					\item Baixa tensão de \textit{offset}: 5$\mu V$ com ganho de 128;
					\item Variação de tensão de \textit{offset} aproximada a 0;
					\item Variação de ganho de \unitfrac[0.5]{ppm}{\celsius};
					\item Linearidade de 1.5 ppm;
					\item Alta rejeição de modo comum: 140 dB;
					\item Alta impedância de entrada;
					\item Entrada e saída de sinais diferencial;
				\end{itemize}

				A Figura \ref{img:hw:sch:amp} apresenta o esquemático do bloco de condicionamento de sinal. $V_{sense}P$ e $V_{sense}N$ são as entradas analógicas diferenciais. $V_{amp}P$ e $V_{amp}N$ são as saídas diferenciais. R45, R47 e C51 formam um filtro passa baixa \textit{anti-alias}. $V_{adc}P$ e $V_{adc}N$ são as conexões para o ADC. O restante dos capacitores e resistores do esquemático atuam como filtro de tensão, resistores \textit{pull-up} e \textit{pull-down}.

				As saídas do amplificador são diferenciais, na faixa de 0 a +5 V. Para o melhor aproveitamento da faixa dinâmica, os sinais podem ser deslocados verticalmente pela injeção de tensão na entrada VOCM. A tensão de 2.5 V apresenta o melhor resultado, devido à possibilidade de variação simétrica de $\pm$2.5 V de cada sinal.

				\begin{figure}[h]
					\caption{Esquemático do circuito de amplificação}
					\label{img:hw:sch:amp}
					\includegraphics[width=0.9\linewidth, frame]{images/ampSch}
				\end{figure}



				A Figura \ref{img:hw:sch:protection} apresenta o esquemático do circuito de proteção das entradas do amplificador. O capacitor C14 atua como um filtro passa baixa, juntamente com os resistores R20 e R19. Estes também tem atuam como resistores \textit{pull-down}, estabilizando as tensões de entrada quando o sensor está desconectado ou quando este não apresenta conexão com o referencial do amplificador. O diodo D2 atua como ceifador de tensão bi-direcional.

				\begin{figure}[h]
					\caption{Esquemático do circuito de proteção}
					\label{img:hw:sch:protection}
					\centering
					\includegraphics[width=\linewidth, frame]{images/protectionSch}
				\end{figure}


			\subsection{Conversão A/D}\label{sec:hw:sch:digital}

				Neste trabalho o conversor ADS1259 da Texas Instruments\textsuperscript{\textregistered} foi utilizado. Conforme o \textit{datasheet} as principais características são:

				\begin{itemize}
					\item Taxa de amostragem variável de 10 Sa/s a 14,4 kSa/s;
					\item Variação de \textit{offset}: 0,05$\mu$\unitfrac{V}{\celsius};
					\item Variação do ganho: 0,5 \unitfrac{ppm}{\celsius};
					\item Variação da referência interna: 10 \unitfrac{ppm}{\celsius};
					\item 24 bits;
					\item Baixo consumo de energia: 13 $mW$ durante operação;
					\item Topologia $\Delta\Sigma$;
					\item Comunicação Digital Serial SPI.
				\end{itemize}

				A Figura \ref{img:hw:sch:adc} apresenta as conexões elétricas do ADC ADS1259. $V_{adc}P$ e $V_{adc}N$ são as componentes da entrada diferencial de sinal. Da mesma forma que o circuito de amplificação, resistores e capacitores são utilizados como elementos de filtros, \textit{pull-ups} e \textit{pull-downs}.

				A comunicação com o ADC é realizada através do barramento SPI (sinais CS, DIN, SCLK, DOUT). Os sinais digitais DRDY e START são utilizados para sinalização do fim de conversão e comando para início de conversão, respectivamente. O sinal START pode ser conectado a mais de um módulo, permitindo assim que as medidas sejam realizadas de forma síncrona.

				O ADC possui conexões uso de referência de tensão externa, bem como a saída analógica da referência interna, $V_{ref}$, de 2.5 V. Esta tensão é conectada à entrada de \textit{offset} do amplificador, possibilitando a operação de ambos dispositivos com a maior faixa disponível.

				\begin{figure}[h]
					\caption{Esquemático do circuito ADC}
					\label{img:hw:sch:adc}
					\includegraphics[width=\linewidth, frame]{images/adcSch}
				\end{figure}
%oh, no my friend, don't let yourself get it wrong. i once did and cared, it's just that i don't longer do.


			\subsection{Isolação Usuário - Grandeza}\label{sec:hw:sch:iso}

				Dentre as alternativas para isolação dos sinais de comunicação, os isoladores de sinais digitais Si8662 e Si8650, de 6 e 5 canais respectivamente, foram utilizados. A escolha de um CI é justificada pelo menor volume e área de PCI finais comparados a um circuito discreto. Os isoladores utilizados suportam velocidades de transmissão de até 150 Mbps, enquanto garantindo uma tensão de isolação de 5 kV, conforme apresentado em \cite{silicon6ch} e \cite{silicon5ch}. Da mesma forma a fonte de tensão isolada NMJ0505SC foi utilizada, garantindo isolação de 5,2 kV. A tensão nominal de entrada é de 5 V com saída simétrica de $\pm$5 V, conforme apresentado em \cite{murataPSU}.

				O esquemático do circuito é apresentado na Figura \ref{img:hw:sch:iso}. Neste, U3 isola os sinais de controle do ganho (G0 a G4) do amplificador programável e U4 isola os sinais de comunicação (CS, SCLK, DIN, DOUT) e de estado e controle (START, DRDY) do ADC. U3 e U4 são conectados ao barramento de 3,3 V no lado do usuário e 5 V no lado da medição, servindo como um conversor de nível digital.

				\begin{figure}[h]
					\caption{Esquemático de isolação dos sinais digitais}
					\label{img:hw:sch:iso}
					\includegraphics[width=\linewidth, frame]{images/isolationSch}
				\end{figure}


	\section{Sistema de Controle}\label{sec:hw:control}

		Circuitos de controle implementados com FPGAs são muito utilizados em instrumentos de alto desempenho ou grande volume de dados processados, como osciloscópios, geradores de funções e analisadores de potência. Os FPGAs apresentam a característica de processamento paralelo, ou a realização de várias operações simultaneamente. A desvantagem no uso destes dispositivos é o custo e a necessidade de circuitos auxilares de alimentação com diferentes níveis de tensão. Uma alternativa com menor custo são os \simb{uc}. Estes dispositivos apresentam uma variedade de configurações, baixo custo e consumo de energia, tornando-os ideais para projetos que não necessitam o desempenho que os FPGAs apresentam.

		Neste trabalho o \simb{uc} TM4C1294NPCDT da Texas Instruments\textsuperscript{\textregistered} foi utilizado. A escolha deste \simb{uc} é justificada por suas características, disponíveis no \textit{datasheet} \cite{tm4c1294}, como:

		\begin{itemize}
			\item ARM Cortex-M4, CPU de 32 bits e 120 MHz;
			\item 1 MB de memória FLASH;
			\item 256 kB de memória SRAM;
			\item 6 kB de memória EEPROM;
			\item 2 módulos ADC de 12 bits e 2 MSPS;
			\item Módulos de UART, CAN, SPI, I2C;
			\item USB-OTG Low-Speed e Full-Speed;
			\item Módulo 10/100 Ethernet com MAC+PHY.
		\end{itemize}

		O \simb{uc} pode ser obtido na placa de desenvolvimento EK--TMC1294XL, facilitando a montagem de um protótipo. Esta placa também apresenta uma interface de \textit{debugging}, o que facilita o desenvolvimento do \textit{firmware}. Neste trabalho o ambiente de desenvolvimento integrado (IDE) Code Composer Studio (CCS) fornecido pela Texas Instruments\textsuperscript{\textregistered} foi utilizado. O compilador suporta as linguagens Assembly, C e C++. \simb{uc} são dispositivos simples, sendo a execução de uma tarefa o método mais comum para projetos simples. Programas mais complexos necessitam a utilização de interrupções para o controle de sistemas em tempo real, ou para a execução virtual de múltiplas tarefas.
		\index{C}
		\index{C++}
		\index{TM4C1294}

		Em sistemas que necessitam de controle em tempo-real de processos e a realização de outras tarefas sistemas operacionais (SO) são utilizados. Devido a diversidade de arquiteturas existentes, uma variedade de SOs existem. Estes variam de multi-tarefa com escalonamento cooperativo a versões modificadas do Linux\textsuperscript{\textregistered}. As vantagens de utilização de um SO variam de execução de múltiplas tarefas conforme prioridade, bibliotecas de abstração para interfaces de \textit{hardware}, portabilidade do código desenvolvido e escalabilidade do sistema.
		\index{SO}

		Neste trabalho o SO TI--RTOS v. 2.14.00.10 disponibilizado pela Texas Instruments\textsuperscript{\textregistered} foi utilizado. O TI--RTOS é baseado no \textit{kernel} multi-tarefa, preemptivo e tempo real, SYS/BIOS. Os códigos de configuração e execução foram escritos em C++.
		%Ambos elementos foram desenvolvidos com foco nos \simb{uc}s da Texas Instruments\textsuperscript{\textregistered}.
		\index{C++}
		\index{TI--RTOS}
		\index{RTOS}

		\subsection{Fiwmware}\label{sec:hw:firmware}

			A função \textit{int \textbf{main}(void)} controla a inicialização do \simb{uc}, na ordem: funções do RTOS para a placa EK--TM4C1294XL, inicialização dos módulos de medição, inicialização da funcionalidade USB-CDC e inicialização do \textit{kernel}.

			O \textit{firmware} é separado em 3 tarefas: controle e leitura dos dados adquiridos, interface de console para configuração do sistema e envio de dados via USB. Após a inicialização, o SO executa estas três tarefas em modo \textit{loop} infinito, declaradas estaticamente no arquivo de configuração. As tarefas são sincronizadas com a utilização de eventos e variáveis booleanas. Os processos destas tarefas estão ilustrados nos fluxogramas presentes nas Figuras \ref{img:hw:uc:console}, \ref{img:hw:uc:usbwrite} e \ref{img:hw:uc:acqfcn}. A interrupção \textit{Void \textbf{adcRdy}()} sinaliza o evento \textbf{adcReady}, habilitando a leitura dos dados dos ADCs.

			O RTOS possibilita a implementação de \textit{loops} infinitos e pausas sem tempo limite pela utilização de eventos e semáforos. A chamada de espera em um evento devolve o controle da CPU ao SO, habilitando a chamada de outras tarefas na lista de espera. Os códigos fonte das funções descritas estão contidas no Apêndice \ref{app:source:embedded}.

			Os principais dados utilizados estão organizados da seguinte forma:

			\begin{description}
				\item[eventos] adcReady, sendUSB;
				\item[módulos] voltage, line;
				\item[\textit{bool}] usbSendEn;
				\item[inteiro] sendSel;
				\item[buffer] buff.
			\end{description}

			Os eventos são utilizados para a sincronia inter-tarefas, os módulos são classes em C++ que implementam funções de gerenciamento do amplificador e ADC, o valor booleano usbSendEn é um mapeamento do sinal DTR, sendSel seleciona a variável a ser enviada e buff é o \textit{buffer} de envio. O \textit{buffer} apresenta duas páginas, as quais alternam entre página de escrita dos dados recebidos e de leitura dos dados de envio.

			A tarefa console, ilustrada no fluxograma da Figura \ref{img:hw:uc:console}, oferece uma interface de configuração do \textit{firmware} durante a operação, implementada na função \textit{Void \textbf{consoleFxn}(UArg arg0, UArg arg1)} no código fonte. O console pode ser acessado por um terminal, com comunicação serial RS-232, velocidae de transmissão de 9600 baud/s, 8 bits de dados, sem paridade e 1 bit de parada. Os comandos disponíveis são:



			\begin{description}
				\item[load] Imprime utilização de CPU;
				\item[sleep] Suspende a tarefa durante um período;
				\item[exit] Encerra tarefa;
				\item[gain] Determina ganho específico;
				\item[gi, gd] Incrementa e decrementa ganhos do amplificador;
				\item[gv, gc] Imprime ganho do amplificador e resultante do módulo (sensor + amplificador);
				\item[spi, spi2] Envio de dados ao barramento SPI;
				\item[r] Habilita ou desabilita envio de dados;
				\item[sel] Seleciona variável a ser enviada;
				\item[help] Imprime texto com comandos disponíveis.
			\end{description}

			A função \textbf{usbWrite} realizada uma chamada para a função de envio de dados via interface USB do TI--RTOS. É passada para esta função o ponteiro da página de leitura do \textit{buffer}.

			\begin{figure}[h]
				\caption{Fluxograma da função \textbf{usbWrite}}
				\label{img:hw:uc:usbwrite}
				\centering
				\begin{tikzpicture}[flow chart]
					\node (start)	[start]	{Inicio da\\Tarefa};
					\node (blan1)	[blank, below=of start]	{};
					\node (event)	[decis, below=of blan1]	{Evento\\\textbf{sendUSB}\\Sinalizado?};
					\node (ptr)		[block, right=of event]	{Envia Dados do\\\textit{Buffer} de Leitura};
					\draw [thick, ->]	(start)	--	(event);
					\draw [thick, ->]	(event)	--	node [text label, above] {Sim}	(ptr);
					\draw [thick, ->, shorten >=0pt]	(event.west)	-|	node [text label, above right] {Não}	+(-1,1)	|-	(blan1);
					\draw [thick, ->, shorten >=0pt]	(ptr)	|-	(blan1);
				\end{tikzpicture}
			\end{figure}

	\iffalse
			\begin{figure}[h]
				\caption{Fluxograma da função \textit{adcRdy}}
				\label{img:hw:uc:adcrdy}
				\centering
				\begin{tikzpicture}[flow chart]
					\node (start)	[start]	{Inicio da\\Interrupção};
					\node (get)		[block, right=of start]	{Obtém\\Fonte da\\Interrupção};
					\node (post)	[block, right=of get]	{Posta\\Evento\\\textbf{adcReady}};
					\node (flag)	[block, right=of post]	{Limpa\\\textit{Flag} da\\Interrupção};
					\node (exit)	[start, right=of flag]	{Finaliza Interrupção};
				\end{tikzpicture}
			\end{figure}
	\fi


			A função \textit{Void \textbf{acqFcn}(UArg arg0, UArg arg1)}, ilustrada no fluxograma da Figura \ref{img:hw:uc:acqfcn}, controla a leitura de dados dos módulos, escrita no \textit{buffer} e troca de páginas. A leitura dos módulos é realizada após o evento \textbf{adcReady} ser sinalizado, o qual indica a finalização de conversão de dados dos ADCs. Posteriormente a medida lida é acrescentada ao \textit{buffer} de escrita, e a função retorna ao estado de espera. A troca de páginas ocorre quando a página de escrita é completa, e sinaliza o evento \textbf{sendUSB}, habilitando o envio.

			\begin{figure}[h!]
				\caption{Fluxograma da função \textbf{acqFcn}}
				\label{img:hw:uc:acqfcn}
				\centering
				\begin{tikzpicture}[flow chart, scale=0.6]
					\node (start)	[start]	{Inicio da\\Tarefa};
					\node (event)	[decis, below=of start]	{Evento\\\textbf{adcReady}\\Sinalizado?};
					\node (blan1)	[blank, below=of event]	{};
					\node (selv)	[block, right=of event]	{Lê Módulo\\\textit{voltage}};
					\node (seli)	[block, right=of selv]	{Lê Módulo\\\textit{line}};
					\node (sensel)	[block, below=of seli]	{Switch\\\textbf{sendSel}};
					\node (case1)	[block, below left=of sensel]	{\textit{voltage * line}};
					\node (case2)	[block, below=of case1]	{\textit{line}};
					\node (case3)	[block, below=of case2]	{\textit{voltage}};
					\node (blan2)	[blank, left=of case2]	{};
					\node (page)	[block, below=of blan1]	{Troca Página\\Sinaliza \textbf{sendUSB}};
					\draw [thick, ->]	(start)	--	(event);
					\draw [thick, ->, shorten >=0pt]	(event.west)	-|	node [text label, above right] {Não}	+(-1,-1)	|-	(blan1);
					\draw [thick, ->]	(event)	--	node [text label, above] {Sim}	(selv);
					\draw [thick, ->]	(selv)	--	(seli);
					\draw [thick, ->]	(seli)	--	(sensel);
					\draw [thick, ->]	(sensel)	|-	node [text label, above, near end] {Caso 1} (case1);
					\draw [thick, ->]	(sensel)	|-	node [text label, above, near end] {Caso 2} (case2);
					\draw [thick, ->]	(sensel)	|-	node [text label, above, near end] {Caso 3} (case3);
					\draw [thick, ->, shorten >=0pt]	(case1)	-|	(blan2);
					\draw [thick, ->]	(case2)	-|	node [text label, pos=0.35, above] {Envia Dados}	(page);
					\draw [thick, ->, shorten >=0pt] (case3)	-|	(blan2);
					\draw [thick, ->] (page)	--	(event);
				\end{tikzpicture}
			\end{figure}


		\subsection{Interface Sistema de Controle -- PC}\label{sec:hw:firmware:iface}

			A comunicação entre o computador e o dispositivo de controle é realizada através de uma porta serial via USB, implementada como um dispositivo da classe de comunicação (USB-CDC). A classe CDC é descrita nas normativas do padrão USB a partir da primeira versão, fazendo desnecessária a utilização \textit{drivers} dedicados. Esta característica torna a classe CDC altamente compatível com quase todos os sistemas operacionais e plataformas. Além disso, o protocolo USB permite a existência de várias instâncias de diferentes classes em forma composta.

			A classe CDC foi implementada com o objetivo de retro-compatibilidade com dispositivos equipados com o padrão RS-232, mantendo virtualmente as conexões elétricas dos sinais auxiliares de controle. Além dos sinais do protocolo RS-232, a classe CDC apresenta características vantajosas para diversas aplicações, como a confirmação de recebimento de quadro e retransmissão em caso de perda ou corrupção de dados. A detecção de corrupção é realizada através de CRC (\textit{Cyclic Redundant Check}) integrado ao quadro. O sinal DTR (\textit{Data Terminal Ready}) é usado para a sincronia do envio de dados em sistemas \textit{master-slave}. O programa \textit{myGrapher} atua como mestre e o dispositivo de controle atua como escravo.

			Configurações do protocolo RS-232, como paridade, velocidade e bits de parada não modificam a transmissão realizada, uma vez que os dados são transportados sobre o protocolo USB. Estas configurações são transmitidas entre os dispositivos como informações.

			O TI--RTOS possui suporte ao periférico USB através do pacote de bibliotecas TivaWare. As bibliotecas USB-CDC deste pacote foram utilizadas, evitando complicações com o registro de identificadores que o padrão USB requer.
